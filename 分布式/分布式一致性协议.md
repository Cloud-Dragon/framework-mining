# 分布式一致性协议

[TOC]



### 2PC（Two-Phase Commit，二阶段提交）

二阶段提交是一种强一致性性协议，目前绝大多数关系型数据库采用而极端提交完成分布式事务处理

#### 角色：

- 协调者Coordinator；
- 参与者Participant；

#### 阶段：

- **阶段一：提交事务请求**
  - 协调者询问参与者是否可以提交
  - 各参与者执行事务，记录undo,redo日志
  - 参与者向协调者反馈响应

- **阶段二：执行事务提交/回滚**

  这个阶段会对第一阶段返回的响应做响应处理，若都成功，则执行事务提交，若有一个失败或超时，则执行事务回滚

  - 发送提交/回滚请求
  - 事务提交/回滚
  - 返回结果
  - 完成/回滚事务



需要注意的是事务执行在第一阶段已经完成，第二阶段只是通过各参与者返回的状态确认是提交还是回滚。回滚操作会根据事务日志还原。

#### 存在问题

2PC原理较为简单，实现方便，但是存在以下问题

1、同步阻塞

所有参与该事务操作的逻辑都处理于阻塞状态。即节点之间在等待对方的相应消息时，它将什么也做不了。特别是，当一个节点在已经占有了某项资源的情况下，为了等待其他节点的响应消息而陷入阻塞状态时，当第三个节点尝试访问该节点占有的资源时，这个节点也将连带陷入阻塞状态。

2、 单点问题

一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。

3、 数据不一致

当协调者向所有的参与者发送Commit请求之后发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩贵，导致最终只有部分参与者收到了Commit请求，于是整个分布式系统便出现了数据不一致性现象。

4、太过保守

二阶段提交没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。



### 3PC（Three-Phase Commit，三阶段提交）

3PC就是在2PC基础上将2PC的第一个阶段分为两个阶段：预提交阶段和提交阶段。即由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。

#### 角色：

- 协调者Coordinator；
- 参与者Participant；

#### 过程

- **阶段一：CanCommit**

  - 事件询问，请求中携带事务内容，询问是否可以提交事务
  - 参与者返回响应

- **阶段二：PreCommit**

  针对上个阶段返回的响应做相应的处理

  若所有参与者均返回yes的响应，执行PreCommit

  - 协调者向参与者发送预提交请求
  - 参与者执行事务并记录相关日志；
  - 参与者返回响应

  若存在参与者返回no的响应，或者超时未响应，执行回滚

  - 发送中断请求，协调者向参与者发送abort请求
  - 中断事务

- **阶段三：doCommit**

  同2PC的第二阶段，这个阶段会对第一阶段返回的响应做响应处理，若都成功，则执行事务提交，若有一个失败，则执行事务回滚

  - 发送提交/回滚请求
  - 事务提交/回滚
  - 返回结果
  - 完成/回滚事务

一旦计入阶段三，协调者可能出现，协调者故障或者网络故障等情况，这些情况最终导致参与者无法及时接收到协调者响应，参与者会在超时之后继续提交。



与2PC相比

- 增加了一个询问阶段，询问阶段可以确保尽可能早的发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生。
- 在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，协调者和参与者都继续提交事务，默认为成功，这也是根据概率统计上超时后默认成功的正确性最大。
- 降低参与者的阻塞范围，在出现单点故障后继续达成一致。

#### 存在问题：

三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。

### 向量时钟

向量时钟算法利用了向量这种数据结构将全局各个进程的逻辑时间戳广播给各个进程，通过向量时间戳就能够比较任意两个事件的因果关系（先后关系或者同时发生关系）。向量时钟被用于解决数据冲突检测、强制因果通信等需要判断事件因果关系的问题。



### NWR协议

前面两种协议，都是强一致性协议，等到所有结果都返回才确定，

N：有多少份数据副本
W：一次成功的写操作至少有w份数据写入成功
R：一次成功的读操作至少有R份数据读取成功

###  paxos协议

#### 角色：

- **Proposer**（提出提案）
- **Acceptor**（参与决策）
- **Learner**（不参与提案，只负责接收已确定的提案，一般用于提高集群对外提供读服务的能力）

#### 过程：

1. Prepare阶段
   - **Proposer**选择一个提案编号`M`，向**Acceptor**某个超过半数的子集成员发送该编号的`Prepare`请求
   - `Acceptor`收到`M`编号的请求时，若`M`大于该`Acceptor`已经响应的所有`Prepare`请求的编号中的最大编号`N`，那么他就将`N`反馈给`Proposer`，同时承诺不会再批准任何编号小于`M`的提案
2. Accept阶段
   - 如果Proposer收到超过半数的Acceptor对于M的prepare请求的响应，就发送一个针对`[M,V]`提案的Accept请求给Acceptor，其中`V`是收到的响应编号中编号的最大的提案值，如果响应中不包括任何提案值，那么他就是任意值
   - Acceptor收到这个针对`[M,V]`的Accept请求只要改Acceptor尚未对大于M编号的提案做出过响应，他就通过这个提案
3. Learn阶段（**本阶段不属于选定提案的过程**）
   - Proposer将通过的提案同步到所有的Learner



### Raft协议



### ZAB协议(Zookeeper Atomic Broadcast，zookeeper原子广播协议)

ZAB(Zookeeper Atomic Broadcast)

#### 角色

- **Following** ：Follower节点（从节点）所处的状态。
- **Leading** ：Leader节点（主节点）所处状态。
- **Looking** ：选举状态。



#### 过程：

节点选取

- **阶段一：Leader election**(选举阶段)

- **阶段二：Discovery**(发现极端)

- **阶段三：Synchronization**(同步阶段)

  同步阶段，把Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。



数据写入



## 参考文献

《从Paxos到zookeeper分布式一致性原理与实践》

[分布式一致性机制整理](https://segmentfault.com/a/1190000014503967)