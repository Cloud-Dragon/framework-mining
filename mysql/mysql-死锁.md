



# MySql-死锁

死锁的四个必要条件

（1）互斥条件：一个资源每次只能被一个进程使用。
（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不可剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
（4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

对应到数据库死锁问题上，简单来说就是两个事务互相持有对方需要的锁。



实际应用场景中，数据库死锁的出现与解决远不止几句口诀这么简单

首先要知道mysql什么时候加锁，加什么样的锁



innodb_lock_wait_timeout 等待锁超时回滚事务：
直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout用来设置超时时间。

wait-for graph算法来主动进行死锁检测：

innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。



解决与预防办法

1）以相同的顺序访问表和行。

2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。

4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。

5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。





参考文献

[Deadlocks in InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html)

[死锁的概念以及产生死锁的原因](https://www.kancloud.cn/hanghanghang/os/239542)

[解决死锁之路（终结篇） - 再见死锁](https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html)