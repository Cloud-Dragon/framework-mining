#线程模型


##传统线程模型
1.单线程
  最传统最简洁的线程模型，线程阻塞无法继续处理，同一时间只能处理一个io
2.多线程
   充分利用CPU多核的优势 可以开启多个线程并行处理任务，以网络io为例，可以并行处理多个网络io，但是还是一条线成可以
3.线程池
  多线程碎岩提高了处理能力，但是频繁的创建和销毁线程十分消耗系统资源，而且不利于资源的管理，采用线程池可以有效解决这个问题

事实上针对网络IO可以分解成两个过程来看，一个是建立连接的过程，
传统线程模型采用同一条线程处理这个这两个过程，造成资源的浪费。

##Reactor线程模型

1.单线程Reactor
Reactor线程将处理连接过程和处理数据过程分离开来，线程会处理TCP连接请求，成功建立连接之后会将其注册到多路复用器Selector上，这样当有感兴趣事件到来时，才会去处理，一条线程可以处理多个请求，吞吐量大大增加

2.多线程Reactor
1）创建一个NIO线程作为Acceptor线程，用于监听服务端，接收客户端的TCP连接请求；
2) 创建一个NIO线程池，用于处理读写、编解码等后续事件，它包含一个任务队列和N个可用的线程；
3) 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。串行化模型
3.主从多线程Reactor
单个线程处理连接请求可能存在性能瓶颈
，这里不详细展

##Proactor线程模型
我们在Reactor的基础上分析

Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；


##netty线程模型
netty线程模型是主从Reactor线程模型的一种实现
netty 服务端提供了两个线程池 bossEventLoop

串行化设计,一个selector对应一个NioEventLoop,一个channel只会注册在一个Selector上，被一条线程执行，因而可以
避免线程上下文切换，减少性能损耗
无需处理并发，降低开发难度

NioEventLoop都做了什么

串行化处理

pipeline